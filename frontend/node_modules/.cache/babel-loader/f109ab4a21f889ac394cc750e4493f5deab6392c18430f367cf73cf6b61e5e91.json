{"ast":null,"code":"import _slicedToArray from \"C:/Users/vintd/Documents/GitHub/Reserv/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _defineProperty from \"C:/Users/vintd/Documents/GitHub/Reserv/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport useMediaQuery from './useMediaQuery';\nimport { useMemo } from 'react';\n/**\r\n * Create a responsive hook we a set of breakpoint names and widths.\r\n * You can use any valid css units as well as a numbers (for pixels).\r\n *\r\n * **NOTE:** The object key order is important! it's assumed to be in order from smallest to largest\r\n *\r\n * ```ts\r\n * const useBreakpoint = createBreakpointHook({\r\n *  xs: 0,\r\n *  sm: 576,\r\n *  md: 768,\r\n *  lg: 992,\r\n *  xl: 1200,\r\n * })\r\n * ```\r\n *\r\n * **Watch out!** using string values will sometimes construct media queries using css `calc()` which\r\n * is NOT supported in media queries by all browsers at the moment. use numbers for\r\n * the widest range of browser support.\r\n *\r\n * @param breakpointValues A object hash of names to breakpoint dimensions\r\n */\nexport function createBreakpointHook(breakpointValues) {\n  var names = Object.keys(breakpointValues);\n  function and(query, next) {\n    if (query === next) {\n      return next;\n    }\n    return query ? \"\".concat(query, \" and \").concat(next) : next;\n  }\n  function getNext(breakpoint) {\n    return names[Math.min(names.indexOf(breakpoint) + 1, names.length - 1)];\n  }\n  function getMaxQuery(breakpoint) {\n    var next = getNext(breakpoint);\n    var value = breakpointValues[next];\n    if (typeof value === 'number') value = \"\".concat(value - 0.2, \"px\");else value = \"calc(\".concat(value, \" - 0.2px)\");\n    return \"(max-width: \".concat(value, \")\");\n  }\n  function getMinQuery(breakpoint) {\n    var value = breakpointValues[breakpoint];\n    if (typeof value === 'number') {\n      value = \"\".concat(value, \"px\");\n    }\n    return \"(min-width: \".concat(value, \")\");\n  }\n\n  /**\r\n   * Match a set of breakpoints\r\n   *\r\n   * ```tsx\r\n   * const MidSizeOnly = () => {\r\n   *   const isMid = useBreakpoint({ lg: 'down', sm: 'up' });\r\n   *\r\n   *   if (isMid) return <div>On a Reasonable sized Screen!</div>\r\n   *   return null;\r\n   * }\r\n   * ```\r\n   * @param breakpointMap An object map of breakpoints and directions, queries are constructed using \"and\" to join\r\n   * breakpoints together\r\n   * @param window Optionally specify the target window to match against (useful when rendering into iframes)\r\n   */\n\n  /**\r\n   * Match a single breakpoint exactly, up, or down.\r\n   *\r\n   * ```tsx\r\n   * const PhoneOnly = () => {\r\n   *   const isSmall = useBreakpoint('sm', 'down');\r\n   *\r\n   *   if (isSmall) return <div>On a Small Screen!</div>\r\n   *   return null;\r\n   * }\r\n   * ```\r\n   *\r\n   * @param breakpoint The breakpoint key\r\n   * @param direction A direction 'up' for a max, 'down' for min, true to match only the breakpoint\r\n   * @param window Optionally specify the target window to match against (useful when rendering into iframes)\r\n   */\n\n  function useBreakpoint(breakpointOrMap, direction, window) {\n    var breakpointMap;\n    if (typeof breakpointOrMap === 'object') {\n      breakpointMap = breakpointOrMap;\n      window = direction;\n      direction = true;\n    } else {\n      direction = direction || true;\n      breakpointMap = _defineProperty({}, breakpointOrMap, direction);\n    }\n    var query = useMemo(function () {\n      return Object.entries(breakpointMap).reduce(function (query, _ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          key = _ref2[0],\n          direction = _ref2[1];\n        if (direction === 'up' || direction === true) {\n          query = and(query, getMinQuery(key));\n        }\n        if (direction === 'down' || direction === true) {\n          query = and(query, getMaxQuery(key));\n        }\n        return query;\n      }, '');\n    }, [JSON.stringify(breakpointMap)]);\n    return useMediaQuery(query, window);\n  }\n  return useBreakpoint;\n}\nvar useBreakpoint = createBreakpointHook({\n  xs: 0,\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1400\n});\nexport default useBreakpoint;","map":{"version":3,"names":["useMediaQuery","useMemo","createBreakpointHook","breakpointValues","names","Object","keys","and","query","next","concat","getNext","breakpoint","Math","min","indexOf","length","getMaxQuery","value","getMinQuery","useBreakpoint","breakpointOrMap","direction","window","breakpointMap","_defineProperty","entries","reduce","_ref","_ref2","_slicedToArray","key","JSON","stringify","xs","sm","md","lg","xl","xxl"],"sources":["C:/Users/vintd/Documents/GitHub/Reserv/frontend/node_modules/@restart/hooks/esm/useBreakpoint.js"],"sourcesContent":["import useMediaQuery from './useMediaQuery';\r\nimport { useMemo } from 'react';\r\n/**\r\n * Create a responsive hook we a set of breakpoint names and widths.\r\n * You can use any valid css units as well as a numbers (for pixels).\r\n *\r\n * **NOTE:** The object key order is important! it's assumed to be in order from smallest to largest\r\n *\r\n * ```ts\r\n * const useBreakpoint = createBreakpointHook({\r\n *  xs: 0,\r\n *  sm: 576,\r\n *  md: 768,\r\n *  lg: 992,\r\n *  xl: 1200,\r\n * })\r\n * ```\r\n *\r\n * **Watch out!** using string values will sometimes construct media queries using css `calc()` which\r\n * is NOT supported in media queries by all browsers at the moment. use numbers for\r\n * the widest range of browser support.\r\n *\r\n * @param breakpointValues A object hash of names to breakpoint dimensions\r\n */\r\nexport function createBreakpointHook(breakpointValues) {\r\n  const names = Object.keys(breakpointValues);\r\n  function and(query, next) {\r\n    if (query === next) {\r\n      return next;\r\n    }\r\n    return query ? `${query} and ${next}` : next;\r\n  }\r\n  function getNext(breakpoint) {\r\n    return names[Math.min(names.indexOf(breakpoint) + 1, names.length - 1)];\r\n  }\r\n  function getMaxQuery(breakpoint) {\r\n    const next = getNext(breakpoint);\r\n    let value = breakpointValues[next];\r\n    if (typeof value === 'number') value = `${value - 0.2}px`;else value = `calc(${value} - 0.2px)`;\r\n    return `(max-width: ${value})`;\r\n  }\r\n  function getMinQuery(breakpoint) {\r\n    let value = breakpointValues[breakpoint];\r\n    if (typeof value === 'number') {\r\n      value = `${value}px`;\r\n    }\r\n    return `(min-width: ${value})`;\r\n  }\r\n\r\n  /**\r\n   * Match a set of breakpoints\r\n   *\r\n   * ```tsx\r\n   * const MidSizeOnly = () => {\r\n   *   const isMid = useBreakpoint({ lg: 'down', sm: 'up' });\r\n   *\r\n   *   if (isMid) return <div>On a Reasonable sized Screen!</div>\r\n   *   return null;\r\n   * }\r\n   * ```\r\n   * @param breakpointMap An object map of breakpoints and directions, queries are constructed using \"and\" to join\r\n   * breakpoints together\r\n   * @param window Optionally specify the target window to match against (useful when rendering into iframes)\r\n   */\r\n\r\n  /**\r\n   * Match a single breakpoint exactly, up, or down.\r\n   *\r\n   * ```tsx\r\n   * const PhoneOnly = () => {\r\n   *   const isSmall = useBreakpoint('sm', 'down');\r\n   *\r\n   *   if (isSmall) return <div>On a Small Screen!</div>\r\n   *   return null;\r\n   * }\r\n   * ```\r\n   *\r\n   * @param breakpoint The breakpoint key\r\n   * @param direction A direction 'up' for a max, 'down' for min, true to match only the breakpoint\r\n   * @param window Optionally specify the target window to match against (useful when rendering into iframes)\r\n   */\r\n\r\n  function useBreakpoint(breakpointOrMap, direction, window) {\r\n    let breakpointMap;\r\n    if (typeof breakpointOrMap === 'object') {\r\n      breakpointMap = breakpointOrMap;\r\n      window = direction;\r\n      direction = true;\r\n    } else {\r\n      direction = direction || true;\r\n      breakpointMap = {\r\n        [breakpointOrMap]: direction\r\n      };\r\n    }\r\n    let query = useMemo(() => Object.entries(breakpointMap).reduce((query, [key, direction]) => {\r\n      if (direction === 'up' || direction === true) {\r\n        query = and(query, getMinQuery(key));\r\n      }\r\n      if (direction === 'down' || direction === true) {\r\n        query = and(query, getMaxQuery(key));\r\n      }\r\n      return query;\r\n    }, ''), [JSON.stringify(breakpointMap)]);\r\n    return useMediaQuery(query, window);\r\n  }\r\n  return useBreakpoint;\r\n}\r\nconst useBreakpoint = createBreakpointHook({\r\n  xs: 0,\r\n  sm: 576,\r\n  md: 768,\r\n  lg: 992,\r\n  xl: 1200,\r\n  xxl: 1400\r\n});\r\nexport default useBreakpoint;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}