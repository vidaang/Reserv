{"ast":null,"code":"var alwaysContainsScroll = function alwaysContainsScroll(node) {\n  // textarea will always _contain_ scroll inside self. It only can be hidden\n  return node.tagName === 'TEXTAREA';\n};\nvar elementCanBeScrolled = function elementCanBeScrolled(node, overflow) {\n  var styles = window.getComputedStyle(node);\n  return (\n    // not-not-scrollable\n    styles[overflow] !== 'hidden' &&\n    // contains scroll inside self\n    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === 'visible')\n  );\n};\nvar elementCouldBeVScrolled = function elementCouldBeVScrolled(node) {\n  return elementCanBeScrolled(node, 'overflowY');\n};\nvar elementCouldBeHScrolled = function elementCouldBeHScrolled(node) {\n  return elementCanBeScrolled(node, 'overflowX');\n};\nexport var locationCouldBeScrolled = function locationCouldBeScrolled(axis, node) {\n  var ownerDocument = node.ownerDocument;\n  var current = node;\n  do {\n    // Skip over shadow root\n    if (typeof ShadowRoot !== 'undefined' && current instanceof ShadowRoot) {\n      current = current.host;\n    }\n    var isScrollable = elementCouldBeScrolled(axis, current);\n    if (isScrollable) {\n      var _a = getScrollVariables(axis, current),\n        s = _a[1],\n        d = _a[2];\n      if (s > d) {\n        return true;\n      }\n    }\n    current = current.parentNode;\n  } while (current && current !== ownerDocument.body);\n  return false;\n};\nvar getVScrollVariables = function getVScrollVariables(_a) {\n  var scrollTop = _a.scrollTop,\n    scrollHeight = _a.scrollHeight,\n    clientHeight = _a.clientHeight;\n  return [scrollTop, scrollHeight, clientHeight];\n};\nvar getHScrollVariables = function getHScrollVariables(_a) {\n  var scrollLeft = _a.scrollLeft,\n    scrollWidth = _a.scrollWidth,\n    clientWidth = _a.clientWidth;\n  return [scrollLeft, scrollWidth, clientWidth];\n};\nvar elementCouldBeScrolled = function elementCouldBeScrolled(axis, node) {\n  return axis === 'v' ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);\n};\nvar getScrollVariables = function getScrollVariables(axis, node) {\n  return axis === 'v' ? getVScrollVariables(node) : getHScrollVariables(node);\n};\nvar getDirectionFactor = function getDirectionFactor(axis, direction) {\n  /**\n   * If the element's direction is rtl (right-to-left), then scrollLeft is 0 when the scrollbar is at its rightmost position,\n   * and then increasingly negative as you scroll towards the end of the content.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollLeft\n   */\n  return axis === 'h' && direction === 'rtl' ? -1 : 1;\n};\nexport var handleScroll = function handleScroll(axis, endTarget, event, sourceDelta, noOverscroll) {\n  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);\n  var delta = directionFactor * sourceDelta;\n  // find scrollable target\n  var target = event.target;\n  var targetInLock = endTarget.contains(target);\n  var shouldCancelScroll = false;\n  var isDeltaPositive = delta > 0;\n  var availableScroll = 0;\n  var availableScrollTop = 0;\n  do {\n    var _a = getScrollVariables(axis, target),\n      position = _a[0],\n      scroll_1 = _a[1],\n      capacity = _a[2];\n    var elementScroll = scroll_1 - capacity - directionFactor * position;\n    if (position || elementScroll) {\n      if (elementCouldBeScrolled(axis, target)) {\n        availableScroll += elementScroll;\n        availableScrollTop += position;\n      }\n    }\n    if (target instanceof ShadowRoot) {\n      target = target.host;\n    } else {\n      target = target.parentNode;\n    }\n  } while (\n  // portaled content\n  !targetInLock && target !== document.body ||\n  // self content\n  targetInLock && (endTarget.contains(target) || endTarget === target));\n  // handle epsilon around 0 (non standard zoom levels)\n  if (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll)) {\n    shouldCancelScroll = true;\n  } else if (!isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) {\n    shouldCancelScroll = true;\n  }\n  return shouldCancelScroll;\n};","map":{"version":3,"names":["alwaysContainsScroll","node","tagName","elementCanBeScrolled","overflow","styles","window","getComputedStyle","overflowY","overflowX","elementCouldBeVScrolled","elementCouldBeHScrolled","locationCouldBeScrolled","axis","ownerDocument","current","ShadowRoot","host","isScrollable","elementCouldBeScrolled","_a","getScrollVariables","s","d","parentNode","body","getVScrollVariables","scrollTop","scrollHeight","clientHeight","getHScrollVariables","scrollLeft","scrollWidth","clientWidth","getDirectionFactor","direction","handleScroll","endTarget","event","sourceDelta","noOverscroll","directionFactor","delta","target","targetInLock","contains","shouldCancelScroll","isDeltaPositive","availableScroll","availableScrollTop","position","scroll_1","capacity","elementScroll","document","Math","abs"],"sources":["C:/Users/vintd/Documents/GitHub/Reserv/frontend/node_modules/react-remove-scroll/dist/es2015/handleScroll.js"],"sourcesContent":["var alwaysContainsScroll = function (node) {\n    // textarea will always _contain_ scroll inside self. It only can be hidden\n    return node.tagName === 'TEXTAREA';\n};\nvar elementCanBeScrolled = function (node, overflow) {\n    var styles = window.getComputedStyle(node);\n    return (\n    // not-not-scrollable\n    styles[overflow] !== 'hidden' &&\n        // contains scroll inside self\n        !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === 'visible'));\n};\nvar elementCouldBeVScrolled = function (node) { return elementCanBeScrolled(node, 'overflowY'); };\nvar elementCouldBeHScrolled = function (node) { return elementCanBeScrolled(node, 'overflowX'); };\nexport var locationCouldBeScrolled = function (axis, node) {\n    var ownerDocument = node.ownerDocument;\n    var current = node;\n    do {\n        // Skip over shadow root\n        if (typeof ShadowRoot !== 'undefined' && current instanceof ShadowRoot) {\n            current = current.host;\n        }\n        var isScrollable = elementCouldBeScrolled(axis, current);\n        if (isScrollable) {\n            var _a = getScrollVariables(axis, current), s = _a[1], d = _a[2];\n            if (s > d) {\n                return true;\n            }\n        }\n        current = current.parentNode;\n    } while (current && current !== ownerDocument.body);\n    return false;\n};\nvar getVScrollVariables = function (_a) {\n    var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;\n    return [\n        scrollTop,\n        scrollHeight,\n        clientHeight,\n    ];\n};\nvar getHScrollVariables = function (_a) {\n    var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;\n    return [\n        scrollLeft,\n        scrollWidth,\n        clientWidth,\n    ];\n};\nvar elementCouldBeScrolled = function (axis, node) {\n    return axis === 'v' ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);\n};\nvar getScrollVariables = function (axis, node) {\n    return axis === 'v' ? getVScrollVariables(node) : getHScrollVariables(node);\n};\nvar getDirectionFactor = function (axis, direction) {\n    /**\n     * If the element's direction is rtl (right-to-left), then scrollLeft is 0 when the scrollbar is at its rightmost position,\n     * and then increasingly negative as you scroll towards the end of the content.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollLeft\n     */\n    return axis === 'h' && direction === 'rtl' ? -1 : 1;\n};\nexport var handleScroll = function (axis, endTarget, event, sourceDelta, noOverscroll) {\n    var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);\n    var delta = directionFactor * sourceDelta;\n    // find scrollable target\n    var target = event.target;\n    var targetInLock = endTarget.contains(target);\n    var shouldCancelScroll = false;\n    var isDeltaPositive = delta > 0;\n    var availableScroll = 0;\n    var availableScrollTop = 0;\n    do {\n        var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];\n        var elementScroll = scroll_1 - capacity - directionFactor * position;\n        if (position || elementScroll) {\n            if (elementCouldBeScrolled(axis, target)) {\n                availableScroll += elementScroll;\n                availableScrollTop += position;\n            }\n        }\n        if (target instanceof ShadowRoot) {\n            target = target.host;\n        }\n        else {\n            target = target.parentNode;\n        }\n    } while (\n    // portaled content\n    (!targetInLock && target !== document.body) ||\n        // self content\n        (targetInLock && (endTarget.contains(target) || endTarget === target)));\n    // handle epsilon around 0 (non standard zoom levels)\n    if (isDeltaPositive &&\n        ((noOverscroll && Math.abs(availableScroll) < 1) || (!noOverscroll && delta > availableScroll))) {\n        shouldCancelScroll = true;\n    }\n    else if (!isDeltaPositive &&\n        ((noOverscroll && Math.abs(availableScrollTop) < 1) || (!noOverscroll && -delta > availableScrollTop))) {\n        shouldCancelScroll = true;\n    }\n    return shouldCancelScroll;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}